# レシピ管理システム 技術課題 仕様書（完全確定版）

## 0. 目的と前提

本仕様書は、株式会社エブリー 技術課題「レシピ管理システム」について、**実装者（人/AI）が迷わず実装に着手できる**最終仕様を定義する。

* 必須：Part1（データ構造）、Part2（自前ソート、2制約0-1ナップサック）
* 任意：Part3（CLI、永続化なし）
* 計算量爆発の回避、出力の決定性（tie-break）の担保、入出力の厳密化を重視
* 標準ライブラリは使用可（例：JSONパース、CLI引数解析）

---

## 1. スコープ

### 1.1 必須（Part1/2）

* Recipeを中心としたデータモデルの定義
* JSON（5件以上）読み込み
* `orderBy(id|name|calories|cookingTime)` と `order(asc|desc)` によるソート

  * **言語組み込みのソートAPIは禁止**
* `maxCalories` と `maxCookingTime` 制約下で、タンパク質最大のレシピ組合せ（0-1）を計算

### 1.2 任意（Part3）

* CLI（list / sort / knapsack）
* 永続化不要

---

## 2. データモデル

### 2.1 Recipe

| フィールド       | 型            | 必須 | 備考                   |
| ----------- | ------------ | -- | -------------------- |
| id          | string       | ✓  | 一意・空文字不可。文字列として辞書順比較 |
| name        | string       | ✓  |                      |
| description | string       | △  |                      |
| servings    | number       | ✓  |                      |
| cookingTime | number       | ✓  | **分（Raw値として小数可）**    |
| category    | string       | ✓  | enumキー               |
| ingredients | Ingredient[] | ✓  |                      |
| steps       | Step[]       | ✓  | 手順（orderで順序管理）       |
| nutrition   | Nutrition    | ✓  | calories/nutrients   |

### 2.2 Ingredient / Amount

```json
{
  "name": "トマト",
  "amount": { "raw": "2個", "value": 2, "unit": "個" }
}
```

* `raw` 必須
* `value` / `unit` 任意

### 2.3 Step

| フィールド    | 型      | 必須 |
| -------- | ------ | -- |
| order    | number | ✓  |
| text     | string | ✓  |
| timerSec | number | △  |

**確定ルール**

* `Step.timerSec` は **アルゴリズム（ソート/ナップサック）に使用しない**
* 妥当性検証（負値禁止など）は実装しても良いが必須ではない
* ナップサック時間制約に使うのは **必ず `Recipe.cookingTime`（分）**

### 2.4 Category（enumキー）

`staple / main / side / soup / dessert / other`

### 2.5 Nutrition

```json
{
  "calories": 450.5,
  "nutrients": { "protein": 32.4 }
}
```

* `calories`：Raw値として小数可
* `nutrients["protein"]`：固定キー（Raw値として小数可）
* protein欠落は 0 扱い（警告は任意）

---

## 3. 数値の扱い（Raw値と計算値の分離）

### 3.1 基本方針

* JSONから読み込んだ `calories / cookingTime / protein` は **Raw値（小数可）として保持**
* **ソートの比較**・**CLI表示**では **Raw値を使用**
* **ナップサックDPの計算に入る直前のみ**、丸めて整数化した **計算用値（int）**を生成して使用

### 3.2 ナップサック計算用の丸め規則（計算時のみ）

| 値           | 正規化規則（int化）   |
| ----------- | ------------- |
| calories    | 四捨五入して整数 kcal |
| cookingTime | 四捨五入して整数 分    |
| protein     | 四捨五入して整数      |

---

## 4. CLI仕様（任意Part3、ただし提出では有利）

### 4.1 引数解析

* CLI引数解析は **標準ライブラリ使用可**

  * Python例：`argparse`

### 4.2 コマンド

```
recipe list --data <path>
recipe sort --data <path> --orderBy <id|name|calories|cookingTime> --order <asc|desc>
recipe knapsack --data <path> --maxCalories <number> --maxCookingTime <number>
```

### 4.3 出力フォーマット（厳守）

* **すべてのコマンドの標準出力はJSONのみ**（人間可読な表形式は禁止）
* 数値は原則 **Raw値を出力**（例：caloriesが450.5なら450.5を表示）

  * ただし knapsack の合計値については、下記 6.6 のルールに従う

---

## 5. ソート仕様（Part2-1）

### 5.1 禁止事項

* 言語組み込みのソートAPI禁止（例：`sorted`, `list.sort`, `Array.sort`, `Collections.sort`）

### 5.2 許可事項（明確化）

* 自作ソートアルゴリズム（merge/quick/heap 等）
* 線形探索、比較、swap
* **比較演算子（`<`, `>`, `==`, `<=`, `>=`）の使用は許可**
  ※比較演算子まで自作する必要はない（課題趣旨から外れるため）

### 5.3 比較値

* `orderBy=calories/cookingTime` は **Raw値（小数含む）**で比較
* `orderBy=id/name` は **言語標準の文字列比較**

### 5.4 tie-break（ソート時）

1. 主キー
2. `id` 昇順（文字列辞書順）
3. 入力順（安定ソート前提）

---

## 6. ナップサック仕様（Part2-2）

### 6.1 問題定義

* 重み1：`calories_int`（丸め後整数）
* 重み2：`cookingTime_int`（丸め後整数）
* 価値：`protein_int`（丸め後整数）
* 0-1（各レシピは選択0/1）

### 6.2 DP定義

```
dp[c][t] = 達成可能な最大 protein_int
```

* DP中は **protein_int（数値）のみ保持**
* 経路復元のための parent を保持してよい（方法は実装者に委ねる）

### 6.3 計算量上限（式を厳密化・確定）

DPテーブルサイズが以下を満たす場合のみ密DPを実行する：

```
(maxCalories_int + 1) * (maxCookingTime_int + 1) <= 1,000,000
```

満たさない場合：

* 警告を出してエラー終了（exit code 1）

### 6.4 最適セル選択（tie-breakのための事後探索）

DP構築後、全セル `(c,t)` を走査し、次の順で `(best_c, best_t)` を選ぶ：

1. `dp[c][t]` 最大
2. その中で `c` 最小
3. その中で `t` 最小

選択後 `(best_c, best_t)` から経路復元し、選択レシピ集合を得る。

### 6.5 tie-break（最終解の定義：ID辞書順の厳密化）

最終解は以下の順で一意に決める：

1. 合計 protein_int 最大
2. 合計 calories_int 最小
3. 合計 cookingTime_int 最小
4. **IDリスト辞書順が最小の組合せ**

ここで「IDリスト辞書順」は **Pythonのlist同士の辞書順比較**に準拠する定義とする：

* 両方を `selectedIds`（辞書順昇順でソート済み）とした上で、
* `selectedIdsA < selectedIdsB` の判定と同じ規則（先頭から比較、短い方が先に終われば小さい）

※Python以外で実装する場合も、この規則に合わせる。

> 実装ヒント（要件ではない）
> 候補レシピ列を `id` 昇順にしてDPすると、経路復元時の分岐で迷いが減る。ただし **最終的に 6.5 を満たせば良い**。

### 6.6 knapsack 出力JSON（最重要・厳守）

`recipe knapsack ...` は **以下のJSON構造を厳守**する。

```json
{
  "selectedIds": ["R001", "R003"],
  "totalProtein": 55,
  "totalCalories": 1100,
  "totalCookingTime": 40
}
```

**出力値のルール（確定）**

* `selectedIds`：辞書順昇順（文字列比較）で出力
* `totalProtein` / `totalCalories` / `totalCookingTime`：**丸め後の整数（*_int）の合計値**を出力

  * 理由：最適化・制約判定が整数に基づくため、出力も同一基準に統一し、採点の決定性を高める

---

## 7. IDの辞書順定義

* `id` は **文字列として辞書順比較**
* `"10" < "2"` が true
* 制約：空文字不可、全レシピで一意
* サンプルデータは `"R001"` 形式推奨

---

## 8. エラー処理（終了コード含む）

### 8.1 終了コード（確定）

* 成功：0
* エラー：1

### 8.2 エラー例

* JSON構文エラー
* 必須フィールド欠落
* id重複 / 空文字
* 負の数値
* DPテーブル上限超過（6.3）

### 8.3 エラー出力

* stderrに人間向けメッセージ（形式自由）
* stdoutは可能ならJSON維持（ただし必須ではない）

---

## 9. サンプルデータ要件（Should Fix採用）

* 5件以上
* 小数（例：450.5）を含むレシピを少なくとも1件入れる（Rawとint化の差分確認用）
* `knapsack` の解が **空集合にならない**ような制約例（maxCalories/maxCookingTime）を想定できるデータにする

---